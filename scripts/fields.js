class Field extends PhysicsObject {

    // objects which cant land on planets, but are attached to/generated by other objects
    // ie the local shield

    constructor(src=undefined, x, y, r, col, hp = 5){
        super(x,y,r)
        this.class = 'Field'
        this.col = col
        this.maxhp = hp
        this.hp = this.maxhp
    }

    iterate(){
        super.iterate()
    }
    destroy(){
        super.destroy()
    }

}

function renderFields(){

    const maxtransparency = 120 // out of 255
    const mintransparency = 30

    // fields, just copypasted bullet renderer
    for(var i = 0; i < pobjects.length;i++){
        if(pobjects[i].shield){
            const transparency = Math.trunc(
                mintransparency + (maxtransparency-mintransparency)*(pobjects[i].shield.hp/pobjects[i].shield.maxhp)
            ).toString(16)
            drawCircle(pobjects[i].shield.x, pobjects[i].shield.y, pobjects[i].shield.r, pobjects[i].shield.col+transparency)
        }
    }
    for(var i = 0; i < config.playerMax; i++){
        if(!sync.conns[i].open){continue}
        for(var ii = 0; ii < sync.others[i].obj.length;ii++){
            let obj = sync.others[i].obj[ii]
            if(obj.shield){
                const transparency = Math.trunc(
                    mintransparency + (maxtransparency-mintransparency)*(obj.shield.hp/obj.shield.maxhp)
                ).toString(16)
                drawCircle(obj.shield.x, obj.shield.y, obj.shield.r, obj.shield.col+transparency)
            }
        }
    }

}

class LocalShield extends Platform {
    constructor(x, y, type=9){
        // type 9 - default local shield
        // 10 - big shield
        super(x, y, 16)
        this.textureID = (type==9?12:13)
        this.cooldown = 0
        this.mcooldown = 180
        this.shield = null
        this.type = type
        this.shp = config.buildings.stats[type].maxhp
        this.maxhp = 15
    }
    renderUI(){
        if(this.cooldown > 0){
            drawBar(this.x, this.y+10, 60 * (this.r/32), 
            this.cooldown / (this.mcooldown))
        }
    }
    generateShield(){
        this.shield = new Field(this, this.x, this.y, config.buildings.stats[this.type].r + (this.id % 20)
            , config.buildings.stats[this.type].col,
            this.shp
        )
        // pobjects.push(this.shield)// to avoid duplicates when syncing is sent without pointers or smt, not on pobjects
    }
    iterate(){
        super.iterate()
        this.cooldown --
        if(this.cooldown < 0 && this.shield == null){
            this.generateShield()
        }
        if(this.shield){
            
            // regen
            this.shield.hp = Math.min(this.shield.maxhp, this.shield.hp+0.01)

            if(this.shield.dead || this.shield.hp <= 0){// shield has died
                this.cooldown=this.mcooldown;this.shield = null// she collect on my garbage, hopefully
            }
        }
        this.updateShield()
    }
    updateShield(){
        this.shield.x = this.x
        this.shield.y = this.y
    }
    destroy(){
        super.destroy()
        this.shield.destroy()
    }
}

class PlanetaryShield extends LocalShield {
    constructor(x, y, type){
        super(x, y, type)
        this.r = 24
        this.textureID = 14
    }
    updateShield(){
        if(this.landed != null){
            if(this.shield){
                this.shield.x = this.landed.x
                this.shield.y = this.landed.y
                this.shield.r = this.landed.r + config.buildings.stats[11].r + (this.id % 20)
            }
        }else{
            this.shield = null
            this.cooldown = this.mcooldown
        }
    }
    generateShield(){
        if(this.landed == null){return}
        super.generateShield()
    }
}
